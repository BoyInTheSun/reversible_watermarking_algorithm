import cv2import osimport numpy as npIMG = os.path.join('test', 'image', 'pic3.jpg')move_x = [-1, -1, 0, 1, 1, 1, 0, -1]move_y = [0, -1, -1, -1, 0, 1, 1, 1]def move_now(x, y):    for i in range(8):        if x == move_x[i] and y == move_y[i]:            return i# binary为带边框的二值图，m, n为横纵坐标，now为当前位移def border_following(binary, m, n, start_m, start_n, now, loop):    for i in range(now, now + 8):        # 顺时针找到第一个非零点        if binary[n + move_y[i % 8], m + move_x[i % 8]] != 0:            now = i % 8            # 右侧为0标记为-2，否则标记为2            if binary[n, m + 1] == 0:                binary[n, m] = -2            else:                binary[n, m] = 2            break    # 周围全是零点，标记-2    else:        binary[n, m] = -2    if not loop:        loop = True    elif n == start_n and m == start_m:        return binary    for i in range(now - 1, now - 9, -1):        # 逆时针找到第一个非零点作为下个中心        temp = binary[n + move_y[i % 8], m + move_x[i % 8]]        if temp != 0:            border_following(binary, m + move_x[i % 8], n + move_y[i % 8], start_m, start_n, move_now(-move_x[i % 8], -move_y[i % 8]), loop)            break    return binaryimg = cv2.imread(IMG)gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)threshold, binary = cv2.threshold(gray, 0, 255, cv2.THRESH_OTSU)for i in range(len(binary)):    for j in range(len(binary[i])):        if binary[i][j] == 255:            binary[i][j] = 1binary_with_border = cv2.copyMakeBorder(binary, 1, 1, 1, 1, cv2.BORDER_CONSTANT, None, [0, 0, 0])binary_with_border = binary_with_border.astype(np.int8)# 输出到csv文件f = open('binary_with_border.csv', 'w')for row in binary_with_border:    for col in row:        f.write(str(col))        f.write(',')    f.write('\n')f.close()after_border_following = border_following(binary_with_border, 1, 1, 1, 1, 0, False)# print(after_border_following)# 输出到csv文件f = open('after_border_following.csv', 'w')for row in after_border_following:    for col in row:        f.write(str(col))        f.write(',')    f.write('\n')f.close()# cv2.imwrite('temp.bmp', binary_with_border)  # 输出图片# cv2.imshow("binary_with_border", binary_with_border)# cv2.waitKey()